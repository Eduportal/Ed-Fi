using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Web;
using System.Web.Http;
using EdFi.Ods.Admin.Models;
using Microsoft.Owin;

namespace EdFi.Ods.Api.Services.Controllers
{

    #region OAuth Authorize

    /// <summary>
    ///     RFC 6749 4.1.1. Authorization Request
    /// </summary>
    //[Route("/oauth/authorize", "GET,POST")]
    public class AuthRequest
    {
        /// <summary>
        ///     REQUIRED. Value MUST be set to "code".
        /// </summary>
        public string Response_type { get; set; }

        /// <summary>
        ///     REQUIRED. The client identifier as described in Section 2.2.
        /// </summary>
        public string Client_id { get; set; }

        /// <summary>
        ///     OPTIONAL. As described in Section 3.1.2.
        /// </summary>
        public string Redirect_uri { get; set; }

        /// <summary>
        ///     OPTIONAL. The scope of the access request as described by Section 3.3.
        /// </summary>
        public string Scope { get; set; }

        /// <summary>
        ///     RECOMMENDED. An opaque value used by the client to maintain
        ///     state between the request and callback. The authorization
        ///     server includes this value when redirecting the user-agent back
        ///     to the client. The parameter SHOULD be used for preventing
        ///     cross-site request forgery as described in Section 10.12.
        /// </summary>
        public string State { get; set; }
    }

    /// <summary>
    ///     RFC 6749 4.1.2. Authorization Response
    /// </summary>
    public class AuthResponse
    {
        private Guid _code = Guid.NewGuid();

        public void SetCode(Guid code)
        {
            _code = code;
        }

        /// <summary>
        ///     REQUIRED. The authorization code generated by the authorization server.
        /// </summary>
        public string Code
        {
            get { return string.IsNullOrEmpty(Error) ? _code.ToString("N") : string.Empty; }
        }

        /// <summary>
        ///     REQUIRED if the "state" parameter was present in the client
        ///     authorization request. The exact value received from the client.
        /// </summary>
        public string State { get; set; }

        /// <summary>
        ///     REQUIRED. A single ASCII [USASCII] error code
        /// </summary>
        public string Error { get; set; }

        public override string ToString()
        {
            var items = new List<string>();

            if (!string.IsNullOrEmpty(State))
                items.Add(string.Format("state={0}", State));

            items.Add(string.IsNullOrEmpty(Error)
                          ? string.Format("code={0}", Code)
                          : string.Format("error={0}", Error));

            return String.Join("&", items);
        }
    }

    //[DefaultRequest(typeof(AuthRequest))]
    public class AuthorizeController : ApiController
    {
        /// <summary>
        ///     Set via dependency injection
        /// </summary>
        public IClientAppRepo ClientAppRepo { get; set; }

        [HttpGet]
        public IHttpActionResult Get([FromUri] AuthRequest request)
        {
            return Post(request);
        }

        [HttpPost]
        public IHttpActionResult Post([FromBody] AuthRequest request)
        {
            if (Request.GetOwinContext() != null)
            {
                Request.GetOwinContext().Response.Headers.Append("Cache-Control", "no-cache, no-store, must-revalidate");
                Request.GetOwinContext().Response.Headers.Append("Pragma", "no-cache");
                Request.GetOwinContext().Response.Headers.Append("Expires", "0");
            }

            var tkResp = new AuthResponse
                             {
                                 State = request.State
                             };

            // verify the request
            if (request.Response_type != "code") tkResp.Error = "invalid_request";

            var client = ClientAppRepo.GetClient(request.Client_id);

            if (client == null)
            {
                // invalid client, give them an invalid code value
                var invalidCode = new ClientAuthorizationCode();
                tkResp.SetCode(invalidCode.Id);
            }
            else
            {
                var code = ClientAppRepo.AddClientAuthorizationCode(client.ApiClientId, request.Scope);
                tkResp.SetCode(code.Id);
            }

            // TODO: use predefined URI domains for redirect_uri in production

            return Ok(tkResp);

            // TODO: the OAuth spec says to do a redirect, but this is 2-legged OAuth
            // create a response url
            //var responseUri = string.Format("{0}?{1}", request.Redirect_uri, tkResp);
            //// redirect the user-agent 
            //var result = new HttpResult(HttpStatusCode.Found)
            //{
            //    Headers = {
            //        { HttpHeaders.Location, responseUri }
            //    }
            //};
            //return result;
        }
    }

    #endregion

    #region OAuth Token Request

    //[Route("/oauth/token", "GET,POST")]
    public class TokenRequest
    {
        public string Code { get; set; }
        public string Client_id { get; set; }
        public string Client_secret { get; set; }
        public string Grant_type { get; set; }
    }

    public class TokenResponse
    {
        private Guid _token = Guid.NewGuid();
        private DateTime _expires = DateTime.Now;

        public void SetToken(ClientAccessToken token)
        {
            _token = token.Id;
            _expires = token.Expiration;
        }

        public string Access_token
        {
            get
            {
                return string.IsNullOrEmpty(Error)
                           ? _token.ToString("N")
                           : null;
            }
        }

        public int? Expires_in
        {
            get
            {
                return string.IsNullOrEmpty(Error)
                           ? new int?((int)_expires.Subtract(DateTime.Now).TotalSeconds)
                           : null;
            }
        }

        public string Token_type
        {
            get
            {
                return string.IsNullOrEmpty(Error)
                           ? "bearer"
                           : null;
            }
        }

        /// <summary>
        ///     REQUIRED. A single ASCII [USASCII] error code
        /// </summary>
        public string Error { get; set; }
    }

    //[DefaultRequest(typeof(TokenRequest))]
    public class TokenController : ApiController
    {
        public IClientAppRepo ClientAppRepo { get; set; }

        [HttpGet]
        public IHttpActionResult Get([FromUri] TokenRequest request)
        {
            return Post(request);
        }

        [HttpPost]
        public IHttpActionResult Post([FromBody] TokenRequest request)
        {
            var resp = new TokenResponse { };

            // verify the request
            if (request.Grant_type != "authorization_code") resp.Error = "invalid_grant";

            try
            {
                var code = new Guid(request.Code);
                var authCode = ClientAppRepo.GetClientAuthorizationCode(code);

                var client = ClientAppRepo.GetClient(request.Client_id, request.Client_secret);

                if (authCode != null && client != null && client.ApiClientId == authCode.ApiClient.ApiClientId && !authCode.IsExpired())
                {
                    var token = ClientAppRepo.AddClientAccessToken(authCode);
                    ClientAppRepo.DeleteClientAuthorizationCode(authCode);
                    resp.SetToken(token);
                }
                else
                {
                    resp.Error = "invalid_client";
                }
            }
            catch (FormatException)
            {
                resp.Error = "invalid_request";
            }

            return Ok(resp);
        }
    }

    #endregion
}